<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Valentine's Day</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      cursor: default;
    }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ======================
   BASIC SETUP
====================== */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 3, 8);
camera.lookAt(0, 1, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = false;
controls.enablePan = false;

/* ======================
   SKY
====================== */
scene.add(new THREE.Mesh(
  new THREE.SphereGeometry(100, 32, 32),
  new THREE.MeshBasicMaterial({ color: 0x0a0a1a, side: THREE.BackSide })
));

/* ======================
   LIGHTING
====================== */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 5);
scene.add(directionalLight);

const spotlight = new THREE.SpotLight(0xffc0cb, 0);
spotlight.position.set(0, 5, 0);
scene.add(spotlight);

/* ======================
   FLOOR & TABLE
====================== */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(50, 50),
  new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

const table = new THREE.Mesh(
  new THREE.BoxGeometry(3, 0.3, 2),
  new THREE.MeshStandardMaterial({ color: 0x3b2a1a })
);
table.position.set(0, 0.15, 0);
scene.add(table);

/* ======================
   INTERACTION CORE
====================== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const clickableObjects = [];

let focusedObject = null;
let targetPosition = null;
let returning = false;
let isDragging = false;

/* ======================
   HELPER
====================== */
function makeClickable(mesh) {
  mesh.userData.originalPosition = mesh.position.clone();
  mesh.userData.originalRotation = mesh.rotation.clone();
  clickableObjects.push(mesh);
}

/* ======================
   OBJECTS
====================== */
function addBox(size, color, pos) {
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(...size),
    new THREE.MeshStandardMaterial({ color })
  );
  mesh.position.copy(pos);
  scene.add(mesh);
  makeClickable(mesh);
  return mesh;
}

addBox([0.8,0.6,0.05], 0x222222, new THREE.Vector3(-0.8,0.6,0)); // photo
addBox([0.6,0.05,0.4], 0xf5f5dc, new THREE.Vector3(0,0.55,0.3)); // letter
addBox([0.5,0.15,0.5], 0x4b2e2b, new THREE.Vector3(-0.3,0.55,-0.3)); // chocolate

const teddy = new THREE.Mesh(
  new THREE.SphereGeometry(0.25,32,32),
  new THREE.MeshStandardMaterial({ color: 0xc68642 })
);
teddy.position.set(0.9,0.6,0);
scene.add(teddy);
makeClickable(teddy);

const ring = new THREE.Mesh(
  new THREE.TorusGeometry(0.12,0.03,16,100),
  new THREE.MeshStandardMaterial({ color: 0xffd700 })
);
ring.rotation.x = Math.PI/2;
ring.position.set(0.4,0.55,-0.3);
scene.add(ring);
makeClickable(ring);

const lemon = new THREE.Mesh(
  new THREE.SphereGeometry(0.15,32,32),
  new THREE.MeshStandardMaterial({ color: 0xffeb3b })
);
lemon.scale.set(1.2,0.8,1);
lemon.position.set(0.8,0.55,0.3);
scene.add(lemon);
makeClickable(lemon);

/* ======================
   FOCUS / RETURN
====================== */
function focusObject(obj) {
  focusedObject = obj;
  targetPosition = new THREE.Vector3(0, 1.2, 0);
  returning = false;
  controls.enabled = false;
  spotlight.target = obj;
  spotlight.intensity = 1;
  ambientLight.intensity = 0.2;
}

function returnObject() {
  if (!focusedObject) return;
  targetPosition = focusedObject.userData.originalPosition.clone();
  returning = true;
  spotlight.intensity = 0;
  ambientLight.intensity = 0.5;
}

/* ======================
   INPUT
====================== */
window.addEventListener("mousedown", () => isDragging = true);
window.addEventListener("mouseup", () => isDragging = false);

window.addEventListener("mousemove", (e) => {
  if (focusedObject && isDragging && !returning) {
    focusedObject.rotation.y += e.movementX * 0.01;
    focusedObject.rotation.x += e.movementY * 0.01;
  }

  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  document.body.style.cursor =
    raycaster.intersectObjects(clickableObjects).length ? "pointer" : "default";
});

window.addEventListener("click", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObjects(clickableObjects);

  if (hits.length > 0) {
    focusObject(hits[0].object);
  } else {
    returnObject();
  }
});

/* ======================
   ANIMATION LOOP
====================== */
function animate() {
  requestAnimationFrame(animate);

  if (focusedObject && targetPosition) {
    focusedObject.position.lerp(targetPosition, 0.08);

    if (returning) {
      focusedObject.rotation.x += (focusedObject.userData.originalRotation.x - focusedObject.rotation.x) * 0.08;
      focusedObject.rotation.y += (focusedObject.userData.originalRotation.y - focusedObject.rotation.y) * 0.08;

      if (focusedObject.position.distanceTo(targetPosition) < 0.01) {
        focusedObject = null;
        targetPosition = null;
        returning = false;
        controls.enabled = true;
      }
    }
  }

  renderer.render(scene, camera);
}
animate();

/* ======================
   RESIZE
====================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
